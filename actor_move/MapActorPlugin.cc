/*
 * Copyright (C) 2016 Open Source Robotics Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

#include "MapActorPlugin.hh"

// using namespace gazebo;
GZ_REGISTER_MODEL_PLUGIN(gazebo::MapActorPlugin)

#define WALKING_ANIMATION "walking"

/////////////////////////////////////////////////
gazebo::MapActorPlugin::MapActorPlugin()
{
}

/////////////////////////////////////////////////
void gazebo::MapActorPlugin::Load(physics::ModelPtr _model, sdf::ElementPtr _sdf)
{
  this->sdf = _sdf;
  this->actor = boost::dynamic_pointer_cast<physics::Actor>(_model);
  this->world = this->actor->GetWorld();

  this->connections.push_back(event::Events::ConnectWorldUpdateBegin(
      std::bind(&gazebo::MapActorPlugin::OnUpdate, this, std::placeholders::_1)));
  this->Reset();

  // Read in the animation factor (applied in the OnUpdate function).
  if (_sdf->HasElement("animation_factor"))
    this->animationFactor = _sdf->Get<double>("animation_factor");
  else
    this->animationFactor = 4.5;

  // Initialize ros, if it has not already bee initialized.
  if (!ros::isInitialized())
  {
    int argc = 0;
    char **argv = NULL;
    ros::init(argc, argv, "gazebo_client",
              ros::init_options::NoSigintHandler);
  }
  // Create our ROS node. This acts in a similar manner to
  // the Gazebo node
  this->rosNode.reset(new ros::NodeHandle("gazebo_client"));

  // Create a named topic, and subscribe to it.
  ros::SubscribeOptions so =
      ros::SubscribeOptions::create<nav_msgs::Path>(
          "/" + this->actor->GetName() + "/target",
          10,
          boost::bind(&gazebo::MapActorPlugin::OnRosMsg, this, _1),
          ros::VoidPtr(), &this->rosQueue);
  this->rosSub = this->rosNode->subscribe(so);

  // Spin up the queue helper thread.
  this->rosQueueThread =
      std::thread(std::bind(&gazebo::MapActorPlugin::QueueThread, this));
}

/// \brief Handle an incoming message from ROS
/// \param[in] _msg is the path generated by A* algorithm
void gazebo::MapActorPlugin::OnRosMsg(const nav_msgs::PathConstPtr &_msg)
{
  this->actor_path = *_msg;
  path_arrived = true;
}

/// \brief ROS helper function that processes messages
void gazebo::MapActorPlugin::QueueThread()
{
  static const double timeout = 0.01;
  while (this->rosNode->ok())
  {
    this->rosQueue.callAvailable(ros::WallDuration(timeout));
  }
}

/////////////////////////////////////////////////
void gazebo::MapActorPlugin::Reset()
{
  this->velocity = 0.8;
  this->lastUpdate = 0;

  if (this->sdf && this->sdf->HasElement("target"))
    this->target = this->sdf->Get<ignition::math::Vector3d>("target");
  else
    this->target = ignition::math::Vector3d(0, -5, 1.2138);

  auto skelAnims = this->actor->SkeletonAnimations();
  if (skelAnims.find(WALKING_ANIMATION) == skelAnims.end())
  {
    gzerr << "Skeleton animation " << WALKING_ANIMATION << " not found.\n";
  }
  else
  {
    // Create custom trajectory
    this->trajectoryInfo.reset(new physics::TrajectoryInfo());
    this->trajectoryInfo->type = WALKING_ANIMATION;
    this->trajectoryInfo->duration = 1.0;

    this->actor->SetCustomTrajectory(this->trajectoryInfo);
  }
}

/////////////////////////////////////////////////
void gazebo::MapActorPlugin::ChooseNewTarget()
{
  ignition::math::Vector3d newTarget(this->target);
  if (!path_arrived)
  {
    while ((newTarget - this->target).Length() < 2.0)
    {
      newTarget.X(ignition::math::Rand::DblUniform(-15.0, 15.0));
      newTarget.Y(ignition::math::Rand::DblUniform(-15.0, 15.0));

      for (unsigned int i = 0; i < this->world->ModelCount(); ++i)
      {
        double dist = (this->world->ModelByIndex(i)->WorldPose().Pos() - newTarget).Length();
        if (dist < 2.0)
        {
          newTarget = this->target;
          break;
        }
      }
    }
  }
  else
  {
    int path_length = (int)this->actor_path.poses.size();
    int n = std::max(path_length, 10);
    newTarget.X(this->actor_path.poses[n - 10].pose.position.x);
    newTarget.Y(this->actor_path.poses[n - 10].pose.position.y);
    // ROS_INFO("X: %f  Y: %f N: %d", this->actor_path.poses[n - 10].pose.position.x, this->actor_path.poses[n - 10].pose.position.y, path_length);
  }
  this->target = newTarget;
}

/////////////////////////////////////////////////
void gazebo::MapActorPlugin::OnUpdate(const common::UpdateInfo &_info)
{
  // Time delta
  double dt = (_info.simTime - this->lastUpdate).Double();

  ignition::math::Pose3d pose = this->actor->WorldPose();
  ignition::math::Vector3d pos = this->target - pose.Pos();

  double distance = pos.Length();

  // Choose a new target position if the actor has reached its current target.
  if (distance < 0.01)
  {
    this->ChooseNewTarget();
    pos = this->target - pose.Pos();
  }

  // Normalize the direction vector, and apply the target weight
  // pos = pos.Normalize() * this->targetWeight;
  pos = pos.Normalize();

  // Compute the yaw orientation
  ignition::math::Angle yaw = atan2(pos.Y(), pos.X()) + 1.5707;
  yaw.Normalize();

  pose.Pos() += pos * this->velocity * dt;
  pose.Rot() = ignition::math::Quaterniond(1.5707, 0, yaw.Radian());

  // Make sure the actor stays within bounds
  pose.Pos().X(std::max(-15.0, std::min(15.0, pose.Pos().X())));
  pose.Pos().Y(std::max(-15.0, std::min(15.0, pose.Pos().Y())));
  pose.Pos().Z(1.2138);

  // Distance traveled is used to coordinate motion with the walking
  // animation
  double distanceTraveled = (pose.Pos() - this->actor->WorldPose().Pos()).Length();

  this->actor->SetWorldPose(pose, false, false);
  this->actor->SetScriptTime(
      this->actor->ScriptTime() + (distanceTraveled * this->animationFactor));
  this->lastUpdate = _info.simTime;
}
